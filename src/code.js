// adiciona um √°udio na fun√ß√£o de jogar que fica inicia e repetindo ate o jogador reiniciar
const som = new Audio("src/music.mp3");
som.loop = true;
som.volume = 0.5;
//Seleciona o bot√£o Jogar e adiciona um listener de clique, quando o clique for efetuado nesse bot√£o, o n√∫mero de rodadas
//escolhido pelo jogador no <select> ser√° lido, dessa forma a fun√ß√£o JogarPeloBotao vai ser chamada com esse n√∫mero e a
//m√∫sica iniciar√°.
const botaoJogar = document.querySelector("#jogar")
botaoJogar.addEventListener("click", () => {
    const seletorDeRodadas = document.querySelector("#rodadas")
    const numeroDeRodadas = seletorDeRodadas[seletorDeRodadas.selectedIndex].value

    jogarPeloBotao(numeroDeRodadas)

    // toca a m√∫sica quando clicar em Jogar
    som.play();
})

// A fun√ß√£o jogarPeloBotao √© a principal fun√ß√£o do reposit√≥rio. Ela que permite
// que o jogo seja jogado, alterando a p√°gina para adicionar os bot√µes para a
// gameplay.
// Ela tem NUMERODERODADAS como par√¢metro, que determina quantas vezes o jogo
// ser√° jogado.
const jogarPeloBotao = (numeroDeRodadas) => {
    // A fun√ß√£o selecionarElemento funciona como interface mais funcional para a
    // intera√ß√£o com o DOM, em compara√ß√£o com a implementa√ß√£o original baseada
    // em objetos. Essa fun√ß√£o seleciona um elemento ELEMENTO baseado na
    // funcionalidade padr√£o do querySelector (ou seja, √© poss√≠vel selecionar
    // um elemento da p√°gina por sua tag, classe ou id).
    const selecionarElemento = elemento => document.querySelector(elemento)

    // A fun√ß√£o criarElemento cria um elemento do tipo ELEMENTO, e retorna o
    // elemento criado caso seja preciso interagir com ele.
    // ARGUMENTOS √© um registro que pode ter as seguintes chaves:
    // - texto: o texto que vai aparecer dentro do elemento;
    // - classe: a classe que o elemento vai ter (bom para CSS);
    // - id: o id que o elemento vai ter (tamb√©m bom para CSS).
    const criarElemento = (elemento, argumentos) => {
        const elementoCriado = document.createElement(elemento)

        if (argumentos.texto) {
            elementoCriado.textContent = argumentos.texto
        }
        if (argumentos.classe) {
            elementoCriado.classList.add(argumentos.classe)
        }
        if (argumentos.id) {
            elementoCriado.setAttribute("id", argumentos.id)
        }

        return elementoCriado
    }

    // A fun√ß√£o acrescentarElemento tanto cria quanto adiciona um elemento ELEMENTO
    // √† um outro PARENTE. Se ELEMENTO for uma string, ent√£o ele ser√° primeiro
    // criado antes de ser adicionado √† p√°gina. Veja @criarElemento para inform√ß√µes
    // sobre o par√¢metro ARGUMENTOS.
    const acrescentarElemento = (parente, elemento, argumentos) => {
        // Cria o elemento primeiro se for uma string.
        if (typeof(elemento) === "string") {
            const elementoNormalizado = criarElemento(elemento, argumentos)

            parente.appendChild(elementoNormalizado)

            return elementoNormalizado
        } else {
            parente.appendChild(elemento)

            return elemento
        }
    }

    // A fun√ß√£o apagarElemento apaga um elemento ELEMENTO encontrado na DOM.
    // ELEMENTO tamb√©m pode ser uma string para evitar a necessidade de selecionar
    // o elemento primeiro.
    const apagarElemento = elemento => {
        if (typeof(elemento) === "string") {
            const elementoNormalizado = selecionarElemento(elemento)
            // Veja:
            // <https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild#simple_examples>.
            // Obrigado a todos os contribuidores do MDN.
            const parente = elementoNormalizado.parentNode

            if (parente) {
                parente.removeChild(elementoNormalizado)
            }
        } else {
            // Veja:
            // <https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild#simple_examples>.
            // Obrigado a todos os contribuidores do MDN.
            const parente = elemento.parentNode

            if (parente) {
                parente.removeChild(elemento)
            }
        }
    }

    // A Fun√ß√£o jogarRodada √© a fun√ß√£o de literalmente somente 1 rodada, ela usa como argumento a escolha do jogador(opcao), de forma que a depender da escolha do jogador
    //o resultado muda, a const computador utiliza-se da fun√ß√£o escolhaDoComputador passando como argumento pra ela o retorno da fun√ß√£o aleatorizar(3), que vai
    // gerar um n√∫mero entre 0 e 2, transformando o n√∫mero em "Pedra", "papel" ou "tesoura".
    //A fun√ß√£o tamb√©m utiliza-se das fun√ß√µes determinarResultadoPedra, determinarResultadoPapel e determinarResultadoTesoura, determinando o vencedor ou se houve empate
    // o retorno da fun√ß√£o ser√° esse determinado resultado.
    const jogarRodada = opcao => {
        // A fun√ß√£o aleatorizar gera um n√∫mero aleat√≥rio maior ou igual a zero,
        // por√©m menor que MAX, √© a fun√ß√£o que √© usada para determinar a escolha entre
        // pedra, papel ou tesoura, o funcionamento da fun√ß√£o √©:
        // Math.random gera um n√∫mero entre 0 e 1, esse n√∫mero √© multiplicado pelo n√∫mero m√°ximo
        // e o Math floor por sua vez corta a parte decimal desse n√∫mero, o tornando inteiro.
        //OBS: O uso de Math.random foi necess√°rio, visto que o javascript n√£o oferece uma forma
        //puramente funcional de gerar n√∫meros ale√°torios.
        const aleatorizar = max => {
            return Math.floor(Math.random()*max)
        }

        // A fun√ß√£o escolhaDoComputador determina, por meio de NUMERO, a escolha que
        // a m√°quina oponente ir√° fazer. Como o jogo s√≥ possui tr√™s op√ß√µes, um erro √©
        // executado caso passe desse n√∫mero.
        const escolhaDoComputador = numero => {
            const error = new RangeError("Valor inesperado, deve estar entre 0 e 2")

            if (numero === 0) {
                return "pedra"
            } else if (numero === 1) {
                return "papel"
            } else if (numero === 2) {
                return "tesoura"
            } else {
                throw error
            }
        }

        // A fun√ß√£o determinarResultado, mediante currying, cria uma interface gen√©rica
        // para determinar o vencedor de um jogo. OPCAO representa a escolha feita pelo
        // jogador. O verdadeiro argumento para essa fun√ß√£o √© ESCOLHADOCOMPUTADOR, pois
        // os outros s√£o usados para criar as fun√ß√µes para cada escolha.
        const determinarResultado = opcao => (perde, ganha) => escolhaDoComputador => {
            const error = new RangeError(`Op√ß√£o inesperada, deve ser "pedra", "papel" ou "tesoura"`)

            if (escolhaDoComputador === opcao) {
                return "empate"
            } else if (escolhaDoComputador === perde) {
                return "computador"
            } else if (escolhaDoComputador === ganha) {
                return "jogador"
            } else {
                throw error
            }
        }

        const determinarResultadoPedra = determinarResultado("pedra")("papel", "tesoura")

        const determinarResultadoPapel = determinarResultado("papel")("tesoura", "pedra")

        const determinarResultadoTesoura = determinarResultado("tesoura")("pedra", "papel")

        const computador = escolhaDoComputador(aleatorizar(3))
        const error = new RangeError(`Erro! op√ß√£o errada, deve ser "pedra", "papel" ou "tesoura"`)

        if (opcao === "pedra") {
            const resultado = determinarResultadoPedra(computador)
            document.getElementById('escolhadocomputador').textContent = `O computador escolheu: ${computador}`
            return resultado
        } else if(opcao === "papel") {
            const resultado = determinarResultadoPapel(computador)
            document.getElementById('escolhadocomputador').textContent = `O computador escolheu: ${computador}`
            return resultado
        } else if(opcao === "tesoura") {
            const resultado = determinarResultadoTesoura(computador)
            document.getElementById('escolhadocomputador').textContent = `O computador escolheu: ${computador}`
            return resultado
        } else {
            throw error
        }
    }

    // Isso apaga os bot√µes originais, que ser√£o substitu√≠dos.
    apagarElemento(".container")
    //Cria√ß√£o de um container para os bot√µes da gameplay, e a cria√ß√£o dos bot√µes Pedra,Papel e Tesoura,
    //os quais s√£o adicionados dinamicamente √† p√°gina.
    const containerBotao = acrescentarElemento(document.body, "div", {classe: "container"})
    const botaoPedra = criarElemento("button", {texto: "ü™® Pedra"})
    const botaoPapel = criarElemento("button", {texto: "üìÑ Papel"})
    const botaoTesoura = criarElemento("button", {texto:  "‚úÇÔ∏è Tesoura"})
    const botoes = [botaoPedra, botaoPapel, botaoTesoura]
    botoes.map((item) => acrescentarElemento(containerBotao, item))
    //Cria√ß√£o de um container para o bot√£o inicio,o mesmo ap√≥s ser clicado pelo jogador, retorna para a p√°gina principal, por fim o bot√£o √© adicionado ao
    //body do documento.
    const containerInicio = acrescentarElemento(document.body, "div", {classe: "container-inicio"})
    const botaoInicio = criarElemento("button",{ texto: "In√≠cio" })
    botaoInicio.addEventListener("click",()=>{
        window.location.href = "index.html"
    })
    acrescentarElemento(document.body, botaoInicio)

    //OBS:Foi necess√°rio o uso do let pois o placar deve ser atualizado em tempo real, sendo assim estadoDoJogo,precisa ser
    //modificado ao decorrer do progama(ou no caso, ao decorrer das rodadas), refletindo os respectivos resultados, o let √© usado
    // para permitir a reatribui√ß√£o.
    let estadoDoJogo = {
        rodadas: numeroDeRodadas,
        pontuacaoJogador: 0,
        pontuacaoComputador: 0
    }
    //Seleciona as divs pr√©-existentes no html que ser√£o utilizadas, para mostrar o resultado de cada rodada e atualizar o placar.
    const divResultado = document.querySelector("#resultado");
    const divPlacar = document.querySelector("#placar");
    // A fun√ß√£o atualizarEstado atualiza o estado do jogo. Determina quem ganhou e quem perdeu por RESULTADO.
    const atualizarEstado = (resultado) => {
        estadoDoJogo.rodadas--;

        // mostra resultado da rodada
        if (resultado === "jogador") {
            estadoDoJogo.pontuacaoJogador++;
            divResultado.textContent = "Voc√™ ganhou a rodada!";
        } else if (resultado === "computador") {
            estadoDoJogo.pontuacaoComputador++;
            divResultado.textContent = "O computador ganhou a rodada!";
        } else {
            divResultado.textContent = "Rodada empatada!";
        }

        // mostra placar atualizado
        divPlacar.textContent =
            `Placar ‚Üí Voc√™: ${estadoDoJogo.pontuacaoJogador} | Computador: ${estadoDoJogo.pontuacaoComputador} | Rodadas restantes: ${estadoDoJogo.rodadas}`;

        // se acabou o jogo
        if (estadoDoJogo.rodadas === 0) {
           const mensagemFinal = "Jogo acabou! " +
            (estadoDoJogo.pontuacaoJogador > estadoDoJogo.pontuacaoComputador ? "üéâ Voc√™ ganhou o jogo!"
            :estadoDoJogo.pontuacaoJogador < estadoDoJogo.pontuacaoComputador ? "üò¢ Voc√™ perdeu o jogo!"
            :"ü§ù O jogo empatou!");
            
            divResultado.textContent = mensagemFinal;

            // desativa os bot√µes para impedir o jogador de continuar clicando ap√≥s o fim de jogo.
            botaoPedra.disabled = true;
            botaoPapel.disabled = true;
            botaoTesoura.disabled = true;
        }
    };

    // A fun√ß√£o lidarComClique serve apenas como event listeners para os bot√µes.
    const lidarComClique = (opcao) => {
        const resultado = jogarRodada(opcao)
        atualizarEstado(resultado)
    }
    //Adiciona listeners para os 3 bot√µes de jogo, cada bot√£o chama a fun√ß√£o lidarComClique com a op√ß√£o correspodente,executando uma rodada do jogo e atualizando o placar.
    botaoPedra.addEventListener("click", () => lidarComClique("pedra"))
    botaoPapel.addEventListener("click", () => lidarComClique("papel"))
    botaoTesoura.addEventListener("click", () => lidarComClique("tesoura"))
}
